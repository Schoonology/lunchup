#!/usr/bin/env node
var fs = require('fs')
var path = require('path')
var csv = require('csv')
var debug = require('debug')('lunchup')
var minimist = require('minimist')
var through = require('through')
var weighted = require('weighted')
var argv = minimist(process.argv.slice(2))
var groupSize = argv._[0]
var inputCsv = argv._[1]
var inputStream = process.stdin
var valueToCohorts = {}
var cohortToValues = []

if (inputCsv) {
  inputStream = fs.createReadStream(path.resolve(process.cwd(), inputCsv))
}

inputStream
  .pipe(csv.parse({
    comment: '#',
    skip_empty_lines: true,
    trim: true
  }))
  .pipe(through(
    function addRecord(record) {
      valueToCohorts[record[0]] = record.slice(1)

      record
        .slice(1)
        .forEach(function (cohortId, index) {
          cohortToValues[index] = cohortToValues[index] || {}
          cohortToValues[index][cohortId] = cohortToValues[index][cohortId] || []
          cohortToValues[index][cohortId].push(record[0])
        })
    },
    function computeGroups() {
      var stream = this
      var numGroups = Math.ceil(Object.keys(valueToCohorts).length / groupSize)
      var groups = new Array(numGroups)
      var smallestGroupSize = 0
      var i

      debug('Records:\n', valueToCohorts)

      for (i = 0; i < groups.length; i++) {
        groups[i] = []
      }

      Object.keys(valueToCohorts)
        // Shuffle
        .sort(function (a, b) {
          return Math.random() * 2 - 1
        })
        // Choose
        .forEach(function (value) {
          var siblings = []
          var preferences = []
          var highScore = Number.MIN_VALUE
          var availableGroups

          valueToCohorts[value].forEach(function (cohort, index) {
            cohortToValues[index][cohort].forEach(function (siblingValue) {
              siblings.push(siblingValue)
            })
          })

          availableGroups = groups
            .map(function (_, index) {
              return index
            })
            .filter(function (index) {
              return groups[index].length === smallestGroupSize
            })

          availableGroups
            .forEach(function (index) {
              var group = groups[index]
              var score = group.reduce(function (score, groupValue) {
                if (siblings.indexOf(groupValue) === -1) {
                  return score + 1
                }

                return score - 1
              }, 0)

              debug('Value: %s - Group: %s - Score: %s - Members: %s', value, index, score, group)

              if (score > highScore) {
                preferences = [index]
                highScore = score
              } else {
                preferences.push(index)
              }
            })

          var choice = weighted.select(preferences)
          groups[choice].push(value)

          debug('Choice: %s', choice)

          if (availableGroups.length === 1) {
            smallestGroupSize++
          }
        })

      groups.forEach(function (group, index) {
        group.forEach(function (value) {
          stream.emit('data', [value, index])
        })
      })
      stream.emit('end')
    }
  ))
  .pipe(csv.stringify())
  .pipe(process.stdout)
